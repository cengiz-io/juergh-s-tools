#!/usr/bin/env python3
#
# Check commits against Ubuntu patch submission rules
#

import argparse
import re
import sys

import git
import requests

RE_SOB = re.compile(r"^Signed-off-by: .* <.*@.*\..*>$")


def pr_info(*args, **kwargs):
    print("--", *args, *kwargs)


def pr_pass(*args, **kwargs):
    print("   P:", *args, **kwargs)


def pr_fail(*args, **kwargs):
    print("   F:", *args, **kwargs)


def get_buglinks(msg):
    """Return a list of BugLinks found in the commit message"""
    buglinks = set()
    for line in msg.split("\n"):
        if line.startswith("BugLink:"):
            buglinks.add(line)
    return buglinks


def get_sob(msg):
    """Return the last signed-off-by line (must be the last non-empty line)"""
    for line in reversed(msg.split("\n")):
        if line.startswith("Signed-off-by: "):
            return line
        if line.strip() == "":
            continue
        return ""
    return ""


def validate_buglink(buglink):
    """Validate a BugLink tag"""
    if buglink.startswith("BugLink: https://bugs.launchpad.net/"):
        url = buglink.split(" ")[1]
        r = requests.get(url, timeout=10)
        if r.status_code == 200:
            return True
    return False


def validate_sob(sob):
    """Validate a Signed-off-by tag"""
    if RE_SOB.match(sob):
        return True
    return False


class Commit:
    """Simple commit class"""

    def __init__(self, commit):
        self.commit = commit
        self.sha = commit.hexsha
        self.title, _, self.body = commit.message.partition("\n")
        self.buglinks = get_buglinks(self.body)
        self.sob = get_sob(self.body)

    def check_buglinks(self):
        """Check BugLinks"""
        if self.buglinks:
            res = True
            for buglink in self.buglinks:
                if validate_buglink(buglink):
                    pr_pass(f"Valid BugLink: {buglink}")
                    continue
                pr_fail(f"Invalid BugLink: {buglink}")
                res = False
            return res

        if self.title.startswith("UBUNTU: [Packaging]") or self.title.startswith(
            "UBUNTU: [Workflow]"
        ):
            # Some specific commits don't require a BugLink
            pr_pass("No BugLink found (not required)")
            return True

        pr_fail("No BugLink found")
        return False

    def check_sob(self):
        """Check Signed-off-by"""
        if not self.sob:
            pr_fail("No SOB found")
            return False

        if validate_sob(self.sob):
            pr_pass(f"Valid SOB: {self.sob}")
            return True

        pr_fail(f"Invalid SOB: {self.sob}")
        return False

    def check(self):
        """Perform all commit checks"""
        pr_info(f'Check commit {self.sha[:12]} ("{self.title}")')
        res = True
        res = self.check_buglinks() and res
        res = self.check_sob() and res
        return res


def check_commits(commits):
    """Check the commits"""
    res = True
    for commit in commits:
        res = commit.check() and res
    return res


def load_commits(repo, start, end):
    """Load the commits of the provided repo and range"""
    commits = []
    repo = git.Repo(repo)
    for c in repo.iter_commits(start + ".." + end, reverse=True):
        commits.append(Commit(c))
    return commits

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("repo", help="Path to git repo")
    parser.add_argument("start", help="Starting sha or object to check")
    parser.add_argument(
        "end", nargs="?", default="HEAD", help="Ending sha or object to check"
    )
    parser.add_argument(
        "--warn-only",
        action="store_true",
        help="Warn only but don't fail if checks fail",
    )
    args = parser.parse_args()

    commits = load_commits(args.repo, args.start, args.end)
    res = check_commits(commits)
    if res:
        print("All checks passed")
        sys.exit(0)

    if args.warn_only:
        print("Warning: Some checks failed")
        sys.exit(0)

    print("Error: Some checks failed")
    sys.exit(1)
