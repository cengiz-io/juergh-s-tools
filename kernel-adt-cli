#!/usr/bin/env python3
#
# Manage ADT tests and results
#

import sys

import argparse
import json
import natsort
import prettytable
import requests

try:
    import browser_cookie3
except ModuleNotFoundError:
    print('Failed to import browser_cookie3. Consider installing it like:\n' +
          '  $ pip3 install browser_cookie3', file=sys.stderr)
    sys.exit(1)

# -----------------------------------------------------------------------------
# Helper functions

def _dec(name, *args, **kwargs):
    def _decorator(func):
        # Because of the sematics of decorator composition if we just append
        # to the options list positional options will appear to be backwards.
        func.__dict__.setdefault(name, []).insert(0, (args, kwargs))
        return func
    return _decorator

def add_help(*args, **kwargs):
    return _dec('help', *args, **kwargs)

def add_arg(*args, **kwargs):
    return _dec('arg', *args, **kwargs)

def error(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def get_browser_cookies():
    '''
    Return the browser cookies for autopkgtest.ubuntu.com
    '''
    cookies = browser_cookie3.firefox(domain_name='autopkgtest.ubuntu.com')
    #    try:
    #        cookies = browser_cookie3.chrome(domain_name=domain)
    #    except AttributeError:
    #        cookies = None
    return cookies

def handle_to_series_source(handle):
    '''
    Return a (series, source) tuple for the provided handle
    '''
    for delim in (':', '/'):
        if delim in handle:
            series, source = handle.split(delim, 1)
            if not source.startswith('linux-'):
                source = 'linux-' + source
            return series, source

    # No delimiter in handle so assume handle is just the series
    return handle, 'linux'

def print_header(series, source, version=None, timestamp=None):
    '''
    Print a header
    '''
    print('Series:    {}'.format(series))
    print('Source:    {}'.format(source))
    if version is not None:
        print('Version:   {}'.format(version))
    if timestamp is not None:
        print('Timestamp: {} UTC'.format(timestamp))
    print()

def print_table(fmt, data):
    '''
    Prtty print a table
    '''
    fmt_map = {
        'p': ['Package', 'package'],
        'a': ['Arch', 'arch'],
        's': ['Status', 'status'],
        'n': ['Annotation', 'annotation'],
        'l': ['Log', 'log'],
        'f': ['Artifacts', 'artifacts'],
        'r': ['Retry URL', 'retry_url'],
    }
    header = [fmt_map[f][0] for f in fmt]
    table = prettytable.PrettyTable()
    table.field_names = header
    for row in data:
        table.add_row([row.get(fmt_map[f][1], '') for f in fmt])
    table.align = 'l'
    print(table)

def table_format_help(default):
    return ('Table formatter string. Specifies the columns to display: ' +
            '(p)ackage, (a)arch, (s)tatus, a(n)otation, (l)og, arti(f)acts, ' +
            '(r)etry_url. If not provided, defaults to \'' + default + '\'.')

# -----------------------------------------------------------------------------
# ADT test results class

class ADTResults():
    def __init__(self, series, source, debug=False):
        self.series = series
        self.source = source
        self.debug = debug

        self.results = None       # ADT test results in dict form
        self.results_list = None  # ADT test results in list form
        self.versions = None      # List of all kernel versions
        self.packages = None      # List of all packages
        self.arches = None        # List of all architectures
        self._get_results()       # Get the above

        self.timestamp = None     # Timestamp of last ADT matrix update
        self._get_timestamp()     # Get the above

        self._get_status_links()  # Get missing status links from autopkgtest

    def _get_results(self):
        '''
        Get ADT results
        '''
        resp = requests.get('https://people.canonical.com/~kernel/status/' +
                            'adt-matrix/{}-{}-detail-results-data.json'.format(
                                self.series, self.source))
        if resp.status_code != 200:
            error('Failed to get results ({})'.format(resp.status_code))
            sys.exit(1)
        results = resp.json()

        if self.debug:
            print('+++ Test results:')
            print(json.dumps(results, indent=4, sort_keys=True))

        # Sanity check
        if ((results['series'] != self.series or
             results['source'] != self.source)):
            error('Mismatched series and/or source')
            sys.exit(1)

        # Rearrange the test results and determine all versions, packages and
        # architectures
        # self.results: version -> package -> arch -> test result
        self.results = {}
        all_versions = {}
        all_packages = {}
        all_arches = {}
        for version, arches in results['history'].items():
            all_versions[version] = 1
            self.results[version] = {}
            for arch, results in arches.items():
                all_arches[arch] = 1
                for result in results:
                    package = result['package']
                    all_packages[package] = 1
                    if package not in self.results[version]:
                        self.results[version][package] = {}
                    self.results[version][package][arch] = result

        if self.debug:
            print('+++ Results dict:')
            print(json.dumps(self.results, indent=4, sort_keys=True))

        # TODO: This needs to be Debian package version sorted
        self.versions = natsort.natsorted(list(all_versions.keys()))
        self.packages = sorted(list(all_packages.keys()))
        self.arches = sorted(list(all_arches.keys()))

        # Fill in missing test results and create the test results list
        self.results_list = {}
        for version in self.versions:
            self.results_list[version] = []
            for package in self.packages:
                if package not in self.results[version]:
                    self.results[version][package] = {}
                for arch in self.arches:
                    if arch not in self.results[version][package]:
                        self.results[version][package][arch] = {
                            'arch': arch,
                            'package': package,
                            'status': '----',
                        }
                    self.results_list[version].append(
                        self.results[version][package][arch])

        # Add missing retry URLs to the latest version
        retry_url = None
        for result in self.results_list[self.versions[-1]]:
            retry_url = result.get('retry_url')
            if retry_url:
                params = dict(param.split('=') for
                              param in retry_url.split('?')[1].split('&'))
                retry_url = retry_url.replace('arch=' + params['arch'],
                                              'arch=__ARCH__')
                retry_url = retry_url.replace('package=' + params['package'],
                                              'package=__PACKAGE__')
                break
        if retry_url:
            for result in self.results_list[self.versions[-1]]:
                url = retry_url
                url = url.replace('__ARCH__', result['arch'])
                url = url.replace('__PACKAGE__', result['package'])
                result['retry_url'] = url
        else:
            error('Unable to find a valid retry URL')

        if self.debug:
            print('+++ Results list:')
            print(json.dumps(self.results_list, indent=4, sort_keys=True))

    def _get_timestamp(self):
        '''
        Get the timestamp of the last ADT matrix update
        '''
        resp = requests.get('https://people.canonical.com/~kernel/status/' +
                            'adt-matrix/{}-{}.html'.format(
                                self.series, self.source))
        if resp.status_code != 200:
            error('Failed to get timestamp ({})'.format(resp.status_code))
            sys.exit(1)
        for line in resp.text.split('\n'):
            if 'ADT Test Matrix for linux-meta' in line:
                self.timestamp = line.split('(')[1].split(')')[0]
                break

    def _get_status_links(self):
        '''
        Get the status links for the latest test results
        '''
        for result in self.results_list[self.versions[-1]]:
            status_link = result.get('status_link')
            if status_link:
                result['log'] = status_link + 'log.gz'
                result['artifacts'] = status_link + 'artifacts.tar.gz'

# -----------------------------------------------------------------------------
# Autopkgtest class

class AutoPkgTest():
    def __init__(self, series, source, debug=False):
        self.series = series
        self.source = source
        self.debug = debug

        self.tests = None       # autopkgtest test status in dict form
        self.tests_list = None  # autopkgtest test status in list form
        self._get_tests()       # Get the above

    def _get_tests(self):  # pylint: disable=R0915
        '''
        Get autopkgtest status of running and queued tests
        '''
        self.tests = {}

        # Get running tests
        resp = requests.get('https://autopkgtest.ubuntu.com/static/' +
                            'running.json')
        if resp.status_code != 200:
            error('Failed to get running tests ({})'.format(resp.status_code))
            sys.exit(1)
        running = resp.json()

        if self.debug:
            print('+++ Running tests:')
            print(json.dumps(running, indent=4, sort_keys=True))

        # Rearrange the running tests and filter out tests for different series
        # and sources
        # self.tests: package -> arch -> [test details]
        for package, runhashes in running.items():  # pylint: disable=R1702
            for _runhash, releases in runhashes.items():
                for release, arches in releases.items():
                    if release != self.series:
                        continue
                    for arch, test_details in arches.items():
                        for trigger in test_details[0].get('triggers', []):
                            if trigger.startswith(self.source + '/'):
                                if package not in self.tests:
                                    self.tests[package] = {}
                                if arch not in self.tests[package]:
                                    self.tests[package][arch] = []
                                details = dict(zip(['params', 'duration',
                                                    'logtail', 'status'],
                                                   test_details + ['RUNNING']))
                                self.tests[package][arch].append(details)
                                break

        # Get queued tests
        resp = requests.get('https://autopkgtest.ubuntu.com/queues.json')
        if resp.status_code != 200:
            error('Failed to get queued tests ({})'.format(resp.status_code))
            sys.exit(1)
        queued = resp.json()

        if self.debug:
            print('+++ Queued tests:')
            print(json.dumps(queued, indent=4, sort_keys=True))

        # Rearrange the queued tests
        # self.tests: package -> arch -> [test details]
        arches = queued.get('ubuntu', {}).get(self.series, {})
        for arch, test_list in arches.items():
            for test in test_list:
                package, details = test.replace('\n', ' ').split(' ', 1)
                details = json.loads(details)
                for trigger in details['triggers']:
                    if trigger.startswith(self.source + '/'):
                        if package not in self.tests:
                            self.tests[package] = {}
                        if arch not in self.tests[package]:
                            self.tests[package][arch] = []
                        details['status'] = 'QUEUED'
                        self.tests[package][arch].append(details)
                        break

        if self.debug:
            print('+++ Tests dict:')
            print(json.dumps(self.tests, indent=4, sort_keys=True))

        # Create the tests list
        self.tests_list = []
        for package, arches in self.tests.items():
            for arch, details in arches.items():
                status = {
                    'RUNNING': 0,
                    'QUEUED': 0,
                }
                for detail in details:
                    if detail['status'] == 'RUNNING':
                        status['RUNNING'] += 1
                    elif detail['status'] == 'QUEUED':
                        status['QUEUED'] += 1
                self.tests_list.append({
                    'arch': arch,
                    'package': package,
                    'status': status,
                    'details': details,
                })

        if self.debug:
            print('+++ Tests list:')
            print(json.dumps(self.tests_list, indent=4, sort_keys=True))

    def get_tests(self, package, arch):
        '''
        Return a list of tests
        '''
        return self.tests.get(package, {}).get(arch, [])

# -----------------------------------------------------------------------------
# Subcommands

@add_help('Show ADT test results.')
@add_arg('version', nargs='?',
         help='Show ADT test results for the provided kernel version. ' +
         'If no version is provided, shows the results for the last ' +
         '(newest) version. Can also be an index (0: first version, -1: ' +
         'last version, ...).')
@add_arg('-t', '--tests', action='store_true',
         help='Show running and queued test status.')
@add_arg('-f', '--format', default='pasn', help=table_format_help('pasn'))
def do_results(args, results):
    if args.version:
        found = False
        for version in results.results:
            if args.version == version:
                found = True
                break
        if not found:
            try:
                version = results.versions[int(args.version)]
                found = True
            except (ValueError, IndexError):
                pass
        if not found:
            error('Invalid version: {}'.format(args.version))
            sys.exit(1)
    else:
        version = results.versions[-1]

    results_list = results.results_list[version]

    # Query autopktest.ubuntu.com for test status
    if args.tests and version == results.versions[-1]:
        apt = AutoPkgTest(results.series, results.source, args.debug)
        for i, result in enumerate(results_list):
            test_status = ''
            for test in apt.get_tests(result['package'], result['arch']):
                if test['status'] == 'RUNNING':
                    test_status = ' (R)'
                elif test_status == '' and test['status'] == 'QUEUED':
                    test_status = ' (Q)'
            result['status'] += test_status
            results_list[i] = result

    print_header(results.series, results.source, version=version,
                 timestamp=results.timestamp)
    print_table(args.format, results_list)

@add_help('Retry ADT tests.',
          help='Retry ADT tests.')
@add_arg('-d', '--dry-run', action='store_true',
         help='Only show which tests would be retried.')
@add_arg('status_package', metavar='status|package', default='MISS', nargs='?',
         help='Either a test status or a package name. If a test status, ' +
         'retry all packages showing the provided status. If a package name, ' +
         'retry the provided package. If not provided, retry all packages ' +
         'showing a \'MISS\' test status.')
def do_retry(args, results):
    status = ''
    package = ''
    arch = ''
    print(args.status_package)
    if args.status_package.isupper() or args.status_package == '----':
        status = args.status_package
    elif '/' in args.status_package:
        package, arch = args.status_package.split('/')
    else:
        package = args.status_package

    version = results.versions[-1]
    retries = []
    for result in results.results_list[version]:
        if result['status'] == status:
            retries.append(result)
        elif result['package'] == package:
            if not arch or result['arch'] == arch:
                retries.append(result)

    print_header(results.series, results.source, version=version)
    print_table('pasn', retries)

    if args.dry_run:
        print('\nDry-run, exiting...')
        return

    # Get the auth cookies from the browsers
    cookies = get_browser_cookies()

    # Retry the tests
    print()
    for result in retries:
        print('Retry {}/{} ... '.format(result['package'], result['arch']),
              end='', flush=True)
        resp = requests.get(result['retry_url'], cookies=cookies)
        if resp.status_code == 200:
            print('OK')
        else:
            print('Failed ({})'.format(resp.status_code))

@add_help('Show kernel versions.')
def do_versions(_args, results):
    print(' '.join(results.versions))

@add_help('Show running and queued autopkgtest tests.')
def do_tests(args, results):
    apt = AutoPkgTest(results.series, results.source, args.debug)

    tests = []
    for test in apt.tests_list:
        tests.append({
            'package': test['package'],
            'arch': test['arch'],
            'status': test['status'],
        })

    print_header(results.series, results.source)
    print_table('pas', tests)

# -----------------------------------------------------------------------------
# Main entry point

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("handle", help='Kernel handle in the form ' +
                        '\'series:source\'.')
    parser.add_argument('--debug', action='store_true',
                        help='Enable debug mode.')

    # Add subparsers for the subcommands and walk through the 'do_' functions
    subparsers = parser.add_subparsers(dest='subcommand', title='subcommands',
                                       required=True)
    module = sys.modules[__name__]
    for attr in (a for a in dir(module) if a.startswith('do_')):
        cmd_name = attr[3:].replace('_', '-')
        cmd_cb = getattr(module, attr)
        cmd_help = getattr(cmd_cb, 'help')[0][0][0]
        cmd_args = getattr(cmd_cb, 'arg', [])

        sparser = subparsers.add_parser(cmd_name, help=cmd_help,
                                        description=cmd_help, add_help=False)
        sparser.add_argument('-h', '--help', action='help')
        for (args, kwargs) in cmd_args:
            sparser.add_argument(*args, **kwargs)
        sparser.set_defaults(func=cmd_cb)

    # Parse the arguments
    args = parser.parse_args()

    # Resolve the handle and get the ADT results
    series, source = handle_to_series_source(args.handle)
    if not source.startswith('linux-meta-'):
        source = source.replace('linux-', 'linux-meta-')
    results = ADTResults(series, source, args.debug)

    # Call the subcommand
    args.func(args, results)

if __name__ == '__main__':
    main()
