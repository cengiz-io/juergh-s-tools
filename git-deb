#!/bin/bash -eu
#
# Helper script for managing Debian/Ubuntu package git repos
#

function out()
{
	local rc=$?

	trap - INT TERM EXIT HUP

	if [ ${rc} -ne 0 ] ; then
		pr_error "Script failed"
	fi

	exit "${rc}"
}

function pr_error()
{
	echo -e "\033[31m${*}\033[0m" 1>&2
}

function pr_warn()
{
	echo -e "\033[33m${*}\033[0m"
}

function set_globals()
{
	local remote repo_name distro

	if ! [ -d .git ] ; then
		pr_error "Not a git repo"
		exit 1
	fi

	remote=$(git remote get-url origin)
	repo_name=${remote##*/}
	repo_name=${repo_name%.git}

	# Figure out what type of repo this is
	if [ "${repo_name}" = kteam-tools ] ; then
		REPO="kteam-tools"
		CHANGELOG=
		SOURCE=
		DERIVATIVE=
	elif [ -e debian/debian.env ] ; then
		REPO="ubuntu-kernel-main"
		# shellcheck disable=SC1091
		. debian/debian.env
		CHANGELOG=${DEBIAN}/changelog
		SOURCE=$(dpkg-parsechangelog -l "${CHANGELOG}" -S Source)
		DERIVATIVE=${SOURCE#linux}
		DERIVATIVE=${DERIVATIVE#-}
	elif [ -e debian/changelog ] ; then
		CHANGELOG=debian/changelog
		SOURCE=$(dpkg-parsechangelog -l "${CHANGELOG}" -S Source)
		case "${SOURCE}" in
			linux-meta*|linux-signed*|linux-restricted-modules*)
				REPO="ubuntu-kernel-dependent"
				DERIVATIVE=${SOURCE#linux}
				DERIVATIVE=${DERIVATIVE#-}
				;;
			*)
				REPO="debian-generic"
				DERIVATIVE=
				;;
		esac
	else
		REPO="unknown"
		CHANGELOG=
		SOURCE=
		DERIVATIVE=
	fi

	# Determine the distro
	DISTRO=
	if [ -n "${CHANGELOG}" ] ; then
		DISTRO=$(dpkg-parsechangelog -l "${CHANGELOG}" -S Distribution)
	fi

	# Set the abbreviated release
	RELEASE=
	if [ -n "${DISTRO}" ] ; then
		distro=${DISTRO:0:1}
		distro=${distro^^}
		RELEASE=${distro}
		if [ -n "${DERIVATIVE}" ] ; then
			RELEASE=${RELEASE}/${DERIVATIVE}
		fi
	fi
}

function print_globals()
{
	local var

	for var in REPO CHANGELOG SOURCE DERIVATIVE DISTRO RELEASE COVER_LETTER \
					DRY_RUN IN_REPLY_TO SUBJECT_PREFIX; do
		printf "%-14s : %s\n" "${var}" "${!var}"
	done
}

function send_patch()
{
	local opts=()

	# Additional options
	if [ "${DRY_RUN}" -eq 1 ] ; then
		opts+=("--dry-run")
	fi

	git send-email .outgoing/*.patch --suppress-cc=all "${opts[@]}"
}

function _get_first_buglink()
{
	for f in "${@}" ; do
		if grep -m1 '^BugLink: ' "${f}" ; then
			return
		fi
	done
}

function _query_lp_bug()
{
	local bug=${1} attr=${2}

	curl -s -S --get "https://api.launchpad.net/devel/bugs/${bug}" | \
		python3 -c "\
import json,sys
obj = json.load(sys.stdin)
print(obj['${attr}'])
"
}

function do_format_patch()
{
	local patch buglink url bug subject blurb
	local opts=()

	# Additional options
	if [ "${COVER_LETTER}" -eq 1 ] ; then
		opts+=("--cover-letter")
	fi
	if [ -n "${SUBJECT_PREFIX}" ] ; then
		opts+=("--subject-prefix=${SUBJECT_PREFIX}")
	fi
	if [ -n "${IN_REPLY_TO}" ] ; then
		opts+=("--in-reply-to=${IN_REPLY_TO}")
		opts+=("--thread")
	fi

	# Create the patchset
	rm -rf .outgoing/
	git format-patch -o .outgoing/ "${opts[@]}" "${@}"

	# Check for
	#   - BugLink or CVE tags
	#   - Requested-by tags for IBM-GT patches
	for patch in .outgoing/*.patch ; do
		if [ "${patch}" = ".outgoing/0000-cover-letter.patch" ] ; then
			continue
		fi
		if ! grep -m1 -qP "^(BugLink: https://.*|CVE-[0-9]{4}-[0-9]*)$" \
			 "${patch}" ; then
			pr_warn "Missing BugLink and/or CVE tag in ${patch#*/}"
		fi
		if [ "${DERIVATIVE}" = "ibm-gt" ] && \
			   ! grep -m1 -qP '^Requested-by: .*@ibm' "${patch}" ; then
			pr_warn "Missing Requested-by tag in ${patch#*/}"
		fi
	done

	# Try to fill in the cover letter
	if [ -f .outgoing/0000-cover-letter.patch ] ; then
		subject=
		blurb=
		buglink=$(_get_first_buglink .outgoing/*.patch)
		if [ -n "${buglink}" ] ; then
			buglink=${buglink#BugLink: }
			url=${buglink%% *}
			if [ "${url}" = "${buglink}" ] ; then
				# Try to query launchpad
				bug=${buglink##*/}
				subject="$(_query_lp_bug "${bug}" title) (LP: #${bug})"
				blurb=$(_query_lp_bug "${bug}" description)
			else
				# Buglink contains a subject, so must be a private bug
				subject=${buglink#* }
				subject=${subject:1:-1}
				blurb="*** PRIVATE BLURB HERE ***"
			fi
		fi
		if [ -n "${subject}" ] ; then
			# shellcheck disable=SC2016
			sed -e 's,\*\*\* SUBJECT HERE \*\*\*,${SUBJECT},' \
				-e 's,\*\*\* BLURB HERE \*\*\*,${BLURB},' \
				.outgoing/0000-cover-letter.patch | \
			SUBJECT=${subject} BLURB=${blurb} envsubst > \
				   .outgoing/0000-cover-letter.patch.tmp
			mv .outgoing/0000-cover-letter.patch.tmp \
			   .outgoing/0000-cover-letter.patch
		fi
	fi

	if [ "${DRY_RUN}" -eq 1 ] ; then
		echo
		echo "git format-patch -o .outgoing/ ${opts[*]} ${*}"
		for patch in .outgoing/*.patch ; do
			pr_warn "Patch ${patch#*/}"
			colordiff < "${patch}"
		done
	fi
}

function do_send_patch()
{
	local commit=${1:-HEAD}

	do_format_patch "${commit}" -1
	send_patch
}

function do_request_pull()
{
	local start=${1:-}
	local refs_heads commit branch remote ref _remote _branch buglink
	local url bug subject blurb name email

	if [ -z "${start}" ] ; then
		# Get the start commit for this pull request
		readarray -t refs_heads < <(git for-each-ref --format="%(objectname)" \
										refs/heads)
		while IFS= read -r commit ; do
			if printf "%s\n" "${refs_heads[@]}" | grep -q "${commit}" ; then
				start=${commit}
				break
			fi
		done < <(git log --format="%H" -1000 HEAD~1)
		if [ -z "${start}" ] ; then
			pr_error "Start commit for pull request not found"
			exit 1
		fi
	fi

	# Get the remote where we pushed this branch to
	branch=$(git rev-parse --abbrev-ref HEAD)
	remote=
	while IFS= read -r ref ; do
		_remote=${ref#*refs/remotes/}
		_remote=${_remote%%/*}
		_branch=${ref#*${_remote}/}
		if [ "${_branch}" = "${branch}" ] ; then
			if [ -n "${remote}" ] ; then
				pr_error "Error: Multiple remotes found that contain a" \
						 "branch with the same name"
				exit 1
			fi
			remote=${_remote}
		fi
	done < <(git for-each-ref refs/remotes)
	if [ -z "${remote}" ] ; then
		pr_error "Remote of branch '${branch}' not found"
		exit 1
	fi

	# Determine the subject for this pull request
	buglink=$(git log --format=%b -1 | grep '^BugLink: ' || true)
	buglink=${buglink#BugLink: }
	url=${buglink%% *}
	if [ "${url}" = "${buglink}" ] ; then
		# Try to query launchpad
		bug=${buglink##*/}
		subject="$(_query_lp_bug "${bug}" title) (LP: #${bug})"
		blurb=$(_query_lp_bug "${bug}" description)
	else
		# Buglink contains a subject, so must be a private bug
		subject=${buglink#* }
		subject=${subject:1:-1}
		blurb=
	fi

	name=$(git config user.name)
	email=$(git config user.email)

	cat <<EOF
From $(git log --format=%H -1) Mon Sep 17 00:00:00 2001
From: ${name} <${email}>
Date: $(date -R)
Subject: [${SUBJECT_PREFIX/PATCH/PULL}] ${subject}
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

EOF
	git log --format=%b "${start}".. | grep '^BugLink: ' | sort -r -u
	if [ -n "${blurb}" ] ; then
		echo
		echo "${blurb}"
	fi
	cat <<EOF

Signed-off-by: ${name} <${email}>

--------

EOF
	git request-pull "${start}" "$(git config "remote.${remote}.url")" \
		"${branch}" | sed -e 's,git+ssh://.*@git,git://git,'
}

do_tag()
{
	local version tag

	version=$(dpkg-parsechangelog -S Version)
	tag=v${version}

	git tag -s -m "${tag}" "${tag}"
}

function usage()
{
	cat <<EOF
Usage: git-deb [-c] [-d] [-h] [-i MSG_ID] [-r RELEASE] [-s] [-t TOKEN] [-ns]
               [-v NUM] COMMAND [OPTS]

Helper script for managing Ubuntu package git repos.

Supported commands:
  info                      Show repo information.
  format-patch [OPTS]       Create a patch (series). OPTS are additional
                            options for 'git format-patch'.
  send-patch [COMMIT]       Send the commit COMMIT as a patch email. If COMMIT
                            is not provided, defaults to HEAD.
  request-pull [COMMIT]     Create a pull request.
  tag                       Tag the HEAD commit.

Optional arguments:
  -c, --cover-letter        Add a cover letter.
  -d, --dry-run             Don't send the email.
  -h, --help                Show this help text.
  -i, --in-reply-to MSG_ID  Reply to the given MSG_ID.
  -r, --release RELEASE     The release to include in the subject prefix.
  -s, --resend              Add RESEND to the subject prefix.
  -t, --token TEXT          Add an additional token [TEXT] to the subject
                            prefix.
  -ns, --no-sru             Don't include [SRU] in the subject prefix.
  -v, --version NUM         The revision number of the patch to include in the
                            subject prefix.
EOF
}

# -----------------------------------------------------------------------------
# Main entry point

# Set the default globals
set_globals

COVER_LETTER=0
DRY_RUN=0
IN_REPLY_TO=
resend=0
sru=1
token=
version=0
cmd=

while [ ${#} -gt 0 ] ; do
	case ${1} in
		-c|--cover-letter)
			COVER_LETTER=1
			;;
		-d|--dry-run)
			DRY_RUN=1
			;;
		-h|--help)
			usage
			exit
			;;
		-i|--in-reply-to)
			shift
			IN_REPLY_TO=${1}
			;;
		-r|--release)
			shift
			RELEASE=${1}
			;;
		-s|--resend)
			resend=1
			;;
		-t|--token)
			shift
			token=${1}
			;;
		-ns|--no-sru)
			sru=0
			;;
		-v|--version)
			shift
			version=${1}
			;;
		info|format-patch|send-patch|request-pull|tag)
			cmd=${1//-/_}
			;;
		*)
			if [ -z "${cmd}" ] ; then
				pr_error "Unexpected argument: ${1}" >&2
				exit 1
			fi
			break
			;;
	esac
	shift
done

if [ -z "${cmd}" ] ; then
	usage
	exit 2
fi

# Set the default email subject prefix
SUBJECT_PREFIX=
if [ "${REPO}" = "kteam-tools" ] ; then
	SUBJECT_PREFIX="kteam-tools"
elif [ "${REPO}" != "unknown" ] ; then
	# [SRU]
	if [ "${sru}" -eq 1 ] ; then
		SUBJECT_PREFIX="${SUBJECT_PREFIX}][SRU"
	fi

	# [RELEASE]
	if [ -n "${RELEASE}" ] ; then
		SUBJECT_PREFIX="${SUBJECT_PREFIX}][${RELEASE}"
	fi

	# [TOKEN]
	if [ -n "${token}" ] ; then
		SUBJECT_PREFIX="${SUBJECT_PREFIX}][${token}"
	fi
fi

# Append [PATCH]
SUBJECT_PREFIX="${SUBJECT_PREFIX}][PATCH"

# Append patch version
if [ "${version}" -gt 0 ] ; then
	SUBJECT_PREFIX="${SUBJECT_PREFIX} v${version}"
fi

# Append resend
if [ "${resend}" -eq 1 ] ; then
	SUBJECT_PREFIX="${SUBJECT_PREFIX} resend"
fi

# Remove leading '][' from the subject prefix
SUBJECT_PREFIX=${SUBJECT_PREFIX#][}

print_globals

if [ "${cmd}" = "info" ] ; then
	exit
fi
do_"${cmd}" "${@}"
